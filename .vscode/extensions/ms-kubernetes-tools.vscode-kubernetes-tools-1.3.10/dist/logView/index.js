!function(n){var g={};function t(I){if(g[I])return g[I].exports;var e=g[I]={i:I,l:!1,exports:{}};return n[I].call(e.exports,e,e.exports,t),e.l=!0,e.exports}t.m=n,t.c=g,t.d=function(n,g,I){t.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:I})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,g){if(1&g&&(n=t(n)),8&g)return n;if(4&g&&"object"==typeof n&&n&&n.__esModule)return n;var I=Object.create(null);if(t.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:n}),2&g&&"string"!=typeof n)for(var e in n)t.d(I,e,function(g){return n[g]}.bind(null,e));return I},t.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(g,"a",g),g},t.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},t.p="",t(t.s=0)}([function(module,exports){eval("const vscode = acquireVsCodeApi();\n\nconst CHRONO_UNITS = [\n    { symbol: 'h', seconds: 3600 },\n    { symbol: 'm', seconds: 60 },\n    { symbol: 's', seconds: 1 }\n];\n\nlet fullPageContent = {};\nlet filteredContent = {};\nlet fpcCounter = -1;\nlet filterMatched = false;\nlet schemaColors;\nlet defaultContainer;\nlet isToBottom = false;\nlet isFollowRun = false;\nlet lastScrollTop = 0;\nlet typingTimer;\n\nwindow.addEventListener('message', (event) => {\n    const message = event.data;\n    switch (message.command) {\n        case 'init': {\n            const { containers, colors } = message;\n            schemaColors = JSON.parse(colors);\n            if (containers.length === 1) {\n                defaultContainer = containers[0];\n                return;\n            }\n\n            const containersPanel = document.getElementById('containers-panel');\n            containersPanel.classList.remove('display-none');\n            containersPanel.classList.add('display-inline-block');\n\n            const select = createElement('vscode-select');\n            select.setAttribute('id', 'containers-select');\n            // eslint-disable-next-line @typescript-eslint/prefer-for-of\n            for (let i = 0; i < containers.length; i += 1) {\n                const option = createElement('vscode-option', containers[i], containers[i]);\n                if (i === 0) {\n                    option.setAttribute('selected', '');\n                }\n                select.appendChild(option);\n            }\n            containersPanel.appendChild(select);\n        }\n        case 'content': {\n            const text = message.text.replace(/\\n$/, '');\n            if (!text) {\n                return;\n            }\n            const newContent = text.split('\\n');\n            updateContent(newContent);\n            break;\n        }\n        case 'reset': {\n            const { follow, timestamp, since, tail, destination, wrap } = message;\n            setSettings({\n                follow,\n                timestamp,\n                since,\n                tail,\n                destination,\n                wrap\n            });\n            break;\n        }\n        case 'run': {\n            onRun();\n            break;\n        }\n    }\n});\n\nfunction setSettings(settings) {\n    const { follow, timestamp, since, tail, destination, wrap } = settings;\n\n    if (follow !== undefined) {\n        document.getElementById('follow-chk').checked = follow;\n    }\n\n    if (timestamp !== undefined) {\n        document.getElementById('timestamp-chk').checked = timestamp;\n    }\n\n    if (since !== undefined) {\n        const split = splitSinceDuration(since);\n        document.getElementById('since-input').value = split.number;\n        document.getElementById('since-select').value = split.unit;\n    }\n\n    if (tail !== undefined) {\n        document.getElementById('tail-input').value = tail;\n    }\n\n    if (destination !== undefined) {\n        document.getElementById('destination-select').value = destination;\n    }\n\n    if (wrap !== undefined) {\n        document.getElementById('wrap-chk').checked = wrap;\n    }\n}\n\nfunction debounce(func, wait, immediate) {\n    let timeout;\n    return function () {\n        const context = this, args = arguments;\n        const later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n\nfunction createElement(type, value, content) {\n    const element = document.createElement(type);\n    if (value) { element.value = value; }\n    if (content) { element.textContent = content; }\n    return element;\n}\n\nfunction onRun() {\n    changeVisibilityAfterRun();\n    startLog();\n}\n\nfunction init() {\n    const runBtn = document.getElementById('runBtn');\n    runBtn.addEventListener('click', onRun);\n\n    const stopBtn = document.getElementById('stopBtn');\n    stopBtn.addEventListener('click', (_event) => {\n        isFollowRun = false;\n        changeVisibilityAfterStop();\n        stopLog();\n    });\n\n    const clearBtn = document.getElementById('clearBtn');\n    clearBtn.addEventListener('click', (_event) => {\n        changeVisibilityAfterClear();\n        clear();\n    });\n\n    const resetBtn = document.getElementById('resetBtn');\n    resetBtn.addEventListener('click', (_event) => {\n        reset();\n    });\n\n    const saveSettingsBtn = document.getElementById('saveSettingsBtn');\n    saveSettingsBtn.addEventListener('click', (_event) => {\n        vscode.postMessage({\n            command: 'saveSettings',\n            follow: isFollow(),\n            timestamp: document.getElementById('timestamp-chk').checked,\n            since: getSinceDurationSeconds(),\n            tail: getTail(),\n            destination: getDestinationValue(),\n            wrap: isWrapEnabled()\n        });\n    });\n\n    const bottomBtn = document.getElementById('bottomBtn');\n    bottomBtn.addEventListener('click', (_event) => {\n        scrollToBottom();\n    });\n\n    const wrapChk = document.getElementById('wrap-chk');\n    wrapChk.addEventListener('vsc-change', (event) => {\n        if (event.detail.checked) {\n            switchClass('content', 'white-space-pre', 'white-space-wrap');\n        } else {\n            switchClass('content', 'white-space-wrap', 'white-space-pre');\n        }\n    });\n\n    const filterSelect = document.getElementById('filter-select');\n    filterSelect.addEventListener('vsc-change', (_event) => {\n        resetFilter();\n        if (isRun() && isFiltering()) {\n            runFilter();\n        }\n    });\n\n    const filterInput = document.getElementById('filter-input');\n    filterInput.addEventListener('keyup', (_event) => {\n        resetFilter();\n        if (!isRun()) {\n            return;\n        }\n        if (typingTimer) {\n            clearTimeout(typingTimer);\n        }\n        typingTimer = setTimeout(runFilter, 500);\n    });\n\n    const logPanel = document.getElementById('logPanel');\n    const toBottom = debounce(function () {\n        const st = logPanel.scrollTop;\n        if (st > lastScrollTop) {\n            // scroll down\n            isToBottom = (logPanel.scrollTop + window.innerHeight) >= logPanel.scrollHeight;\n        } else {\n            // scroll up\n            isToBottom = false;\n        }\n        lastScrollTop = st <= 0 ? 0 : st;\n        renderByPagination();\n    }, 250);\n    logPanel.addEventListener(\"scroll\", toBottom);\n\n    vscode.postMessage({\n        command: 'postInitialize'\n    });\n}\n\nfunction resetContent() {\n    fullPageContent = {};\n    fpcCounter = -1;\n}\n\nfunction resetFilter() {\n    filteredContent = {};\n    filterMatched = false;\n}\n\nfunction runFilter() {\n    emptyContent();\n    saveFilteredContent();\n    setHeightContentPanel();\n    renderByPagination();\n}\n\nfunction changeVisibilityAfterRun() {\n    if (getDestinationValue() === 'Terminal') {\n        return;\n    }\n    document.getElementById('runBtn').classList.add('display-none');\n    if (isFollow()) {\n        switchClass('stopBtn', 'display-none', 'display-inline-block');\n    }\n    switchClass('clearBtn', 'display-none', 'display-inline-block');\n}\n\nfunction changeVisibilityAfterClear() {\n    if (document.getElementById('stopBtn').classList.contains('display-none')) {\n        switchClass('clearBtn', 'display-inline-block', 'display-none');\n        switchClass('runBtn', 'display-none', 'display-inline-block');\n    }\n}\n\nfunction changeVisibilityAfterStop() {\n    switchClass('stopBtn', 'display-inline-block', 'display-none');\n}\n\nfunction switchClass(id, classToRemove, classToAdd) {\n    const element = document.getElementById(id);\n    if (element.classList.contains(classToRemove)) {\n        element.classList.remove(classToRemove);\n    }\n    if (!element.classList.contains(classToAdd)) {\n        element.classList.add(classToAdd);\n    }\n}\n\nfunction isRun() {\n    return document.getElementById('runBtn').classList.contains('display-none');\n}\n\nfunction isFiltering() {\n    const filterInput = document.getElementById('filter-input').value;\n    return filterInput.length > 0;\n}\n\nfunction startLog() {\n    resetContent();\n    resetFilter();\n    clear();\n    isFollowRun = isFollow();\n    const options = {\n        container: getContainer(),\n        follow: isFollowRun,\n        timestamp: document.getElementById('timestamp-chk').checked,\n        since: getSinceDurationString(),\n        tail: getTail(),\n        destination: getDestinationValue()\n    };\n    vscode.postMessage({\n        command: 'start',\n        options: JSON.stringify(options)\n    });\n}\n\nfunction stopLog() {\n    vscode.postMessage({\n        command: 'stop'\n    });\n}\n\nfunction clear() {\n    if (!isFollowRun) {\n        resetContent();\n        resetFilter();\n    }\n    setHeightContentPanel(true);\n    emptyContent();\n}\n\nfunction reset() {\n    const containersSelect = document.getElementById('containers-select');\n    if (containersSelect) {\n        containersSelect.selectedIndex = 0;\n    }\n\n    vscode.postMessage({\n        command: 'reset'\n    });\n}\n\nfunction updateContent(newContent) {\n    let content = {};\n    let counter = 0;\n\n    for (const element of newContent) {\n        if (element.length > 0) {\n            content[counter] = element;\n            fpcCounter++;\n            fullPageContent[fpcCounter] = element;\n            counter++;\n        }\n    }\n\n    content = saveFilteredContent(content);\n    setHeightContentPanel();\n    renderByPagination(content);\n    switchClass('clearBtn', 'display-none', 'display-inline-block');\n}\n\nfunction setHeightContentPanel(removeStyle) {\n    if (removeStyle) {\n        document.getElementById('innerLogPanel').style.removeProperty('height');\n    } else {\n        const content = isFiltering() ? filteredContent : fullPageContent;\n        const rows = Object.keys(content).length;\n        const heightDiv = getDefaultDivHeightValue();\n        document.getElementById('innerLogPanel').style.height = `${heightDiv * rows}px`;\n    }\n}\n\nfunction saveFilteredContent(content) {\n    let contentAfterFilter;\n    if (isFiltering()) {\n        contentAfterFilter = filter(content);\n        let fcRows = Object.keys(filteredContent).length - 1;\n        if (fcRows === -1) {\n            filteredContent = contentAfterFilter;\n            return contentAfterFilter;\n        }\n        for (let i = 0; i < Object.keys(contentAfterFilter).length; i += 1) {\n            fcRows++;\n            filteredContent[fcRows] = contentAfterFilter[i];\n        }\n    }\n    return contentAfterFilter;\n}\n\nfunction filter(logs) {\n    const text = logs ? logs : fullPageContent;\n    const filterInput = document.getElementById('filter-input').value;\n    const mode = document.getElementById('filter-select').value;\n    let content = {};\n    if (filterInput.length > 0) {\n        const regex = new RegExp(filterInput);\n        switch (mode) {\n            case 'include':\n                content = filterByFunction(text, (value) => regex.test(value));\n                break;\n            case 'exclude':\n                content = filterByFunction(text, (value) => !regex.test(value));\n                break;\n            case 'before':\n                if (!filterMatched) {\n                    const filterBeforeResult = filterBefore(text, regex);\n                    content = filterBeforeResult.content;\n                    filterMatched = filterBeforeResult.matched;\n                }\n                break;\n            case 'after':\n                if (!filterMatched) {\n                    const filterAfterResult = filterAfter(text, regex);\n                    content = filterAfterResult.content;\n                    filterMatched = filterAfterResult.matched;\n                } else {\n                    content = text;\n                }\n                break;\n            default:\n                break;\n        }\n    } else {\n        content = text;\n    }\n\n    return content;\n}\n\nfunction filterByFunction(text, func) {\n    const content = {};\n    let counter = 0;\n    let innerCounter = 0;\n    while (true) {\n        const value = text[counter];\n        if (!value) {\n            break;\n        }\n        if (func(value)) {\n            content[innerCounter] = value;\n            innerCounter++;\n        }\n        counter++;\n    }\n    return content;\n}\n\nfunction filterBefore(text, regex) {\n    const content = {};\n    let counter = 0;\n    let matched = false;\n    while (true) {\n        const value = text[counter];\n        matched = regex.test(value);\n        if (!value || matched) {\n            break;\n        }\n        content[counter] = value;\n        counter++;\n    }\n    return { matched, content };\n}\n\nfunction filterAfter(text, regex) {\n    const content = {};\n    let counter = 0;\n    let innerCounter = 0;\n    let start = false;\n    let matched = false;\n    while (true) {\n        const value = text[counter];\n        if (!value) {\n            break;\n        }\n        matched = regex.test(value);\n        if (!start && matched) {\n            start = true;\n        }\n        if (start) {\n            content[innerCounter] = value;\n            innerCounter++;\n        }\n        counter++;\n    }\n    return { matched, content };\n}\n\nfunction emptyContent() {\n    const contentDiv = document.getElementById('innerLogPanel');\n    let i = contentDiv.childNodes.length;\n    while (i--) {\n        contentDiv.removeChild(contentDiv.firstChild);\n    }\n    contentDiv.innerHTML = `<code id='content' class='${isWrapEnabled() ? 'white-space-wrap' : 'white-space-pre'} position-relative'></code>`;\n}\n\nfunction renderByPagination(contentToAdd) {\n    if (contentToAdd && Object.keys(contentToAdd).length === 0) {\n        return;\n    }\n    const fullFilteredContent = isFiltering() ? filteredContent : fullPageContent;\n    const totalRows = Object.keys(fullFilteredContent).length - 1;\n    const heightDiv = getDefaultDivHeightValue();\n    const currentPosition = document.getElementById('logPanel').scrollTop;\n    const referenceRow = Math.floor(currentPosition / heightDiv);\n    // identify rows range to draw\n    let lowerRange = referenceRow - 250 < 0 ? 0 : referenceRow - 250;\n    let upperRange = referenceRow + 250 > totalRows ? totalRows : referenceRow + 250;\n    let isPrepend = false;\n\n    const children = document.getElementById('content').children;\n    if (children.length !== 0) {\n        // identify rows range present in DOM\n        const lowestRowInDOM = parseInt(children.item(0).id);\n        const uppestRowInDOM = parseInt(children.item(children.length - 1).id);\n        if (lowerRange < lowestRowInDOM) {\n            if (upperRange >= lowestRowInDOM) {\n                removeChildren(upperRange + 1, uppestRowInDOM);\n                upperRange = lowestRowInDOM - 1;\n                isPrepend = true;\n                document.getElementById('content').style.top = `${lowerRange * heightDiv}px`;\n            } else {\n                emptyContent();\n                document.getElementById('content').style.top = `${lowerRange * heightDiv}px`;\n            }\n            const content = extractRowsToDraw(fullFilteredContent, lowerRange, upperRange);\n            render(beautifyLines(content), lowerRange, isPrepend);\n        } else if (upperRange > uppestRowInDOM) {\n            if (lowerRange <= uppestRowInDOM) {\n                removeChildren(lowestRowInDOM, lowerRange - 1);\n                document.getElementById('content').style.top = `${lowerRange * heightDiv}px`;\n                lowerRange = uppestRowInDOM + 1;\n            } else {\n                emptyContent();\n                document.getElementById('content').style.top = `${lowerRange * heightDiv}px`;\n            }\n            const content = extractRowsToDraw(fullFilteredContent, lowerRange, upperRange);\n            render(beautifyLines(content), lowerRange, isPrepend);\n        }\n    } else {\n        const content = extractRowsToDraw(fullFilteredContent, lowerRange, upperRange);\n        document.getElementById('content').style.top = `${lowerRange * heightDiv}px`;\n        render(beautifyLines(content), lowerRange, isPrepend);\n    }\n}\n\nfunction extractRowsToDraw(content, from, to) {\n    const contentExtracted = {};\n    for (let i = from; i <= to; i += 1) {\n        contentExtracted[i] = content[i];\n    }\n    return contentExtracted;\n}\n\nfunction beautifyLines(contentLines) {\n    const content = {};\n    if (Object.keys(contentLines).length === 0) {\n        return content;\n    }\n\n    const heightDiv = getDefaultDivHeightValue();\n    // eslint-disable-next-line prefer-const\n    for (let [key, value] of Object.entries(contentLines)) {\n        if (!value) {\n            continue;\n        }\n        value = value.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n        value = highlightWords(value);\n        value = /\\n$/.test(value) ? value : `${value}\\n`;\n        content[key] = `<div id=\"${key}\" style=\"min-height: ${heightDiv}px\">${value}</div>`;\n    }\n    return content;\n}\n\nfunction highlightWords(row) {\n    if (!schemaColors) {\n        return row;\n    }\n\n    for (const rule of schemaColors) {\n        const regexp = new RegExp(rule.regex, \"gi\");\n        if (regexp.test(row)) {\n            row = row.replaceAll(regexp, repl);\n            row = row.replaceAll('#ruleColor', rule.color);\n        }\n    }\n    return row;\n}\n\nfunction repl() {\n    const argsLength = arguments.length;\n    const match = arguments[0];\n    const originalString = arguments[argsLength - 1];\n\n    if (!originalString) {\n        return match;\n    }\n\n    const offset = arguments[argsLength - 2];\n\n    const substring = originalString.substring(0, offset + match.length);\n    const indexOpenSpan = substring.lastIndexOf(\"<span\");\n    const indexCloseSpan = substring.lastIndexOf(\"</span>\");\n    if (indexOpenSpan === -1 || indexOpenSpan < indexCloseSpan) {\n        return `<span class=\"#ruleColor\">${match}</span>`;\n    }\n\n    return match;\n}\n\nfunction removeChildren(from, to) {\n    if (to < from) {\n        return;\n    }\n    for (let i = from; i <= to; i++) {\n        const toDelete = document.getElementById(i.toString());\n        if (toDelete) {\n            toDelete.remove();\n        }\n    }\n}\n\nfunction render(content, from, prepend) {\n    const contentElement = document.getElementById('content');\n\n    if (Object.keys(content).length === 0) {\n        const fragment = document.createRange().createContextualFragment('No logs ...');\n        contentElement.appendChild(fragment);\n    } else {\n        const contentToDisplay = concatenateObjectValuesAsString(content, from);\n        const fragment = document.createRange().createContextualFragment(contentToDisplay);\n        if (prepend) {\n            contentElement.prepend(fragment);\n        } else {\n            contentElement.appendChild(fragment);\n        }\n        if (isToBottom) {\n            scrollToBottom();\n        }\n    }\n}\n\nfunction concatenateObjectValuesAsString(object, ix) {\n    let valuesConcatenated = '';\n    while (true) {\n        const value = object[ix];\n        if (!value) {\n            break;\n        }\n        valuesConcatenated += value;\n        ix++;\n    }\n    return valuesConcatenated;\n}\n\nfunction scrollToBottom() {\n    document.getElementById('bottom').scrollIntoView();\n}\n\nfunction getContainer() {\n    const containersSelect = document.getElementById('containers-select');\n    return (containersSelect) ? containersSelect.value : defaultContainer;\n}\n\nfunction isFollow() {\n    return document.getElementById('follow-chk').checked;\n}\n\nfunction getSinceDurationString() {\n    const sinceInput = document.getElementById('since-input').value;\n\n    if (sinceInput <= 0) {\n        return 0;\n    }\n\n    const sinceType = document.getElementById('since-select').value;\n    return `${sinceInput}${sinceType}`;\n}\n\nfunction getSinceDurationSeconds() {\n    const sinceInput = document.getElementById('since-input').value;\n    const since = Number.parseInt(sinceInput, 10);\n\n    if (since <= 0) {\n        return -1;\n    }\n\n    const sinceType = document.getElementById('since-select').value;\n    const unit = CHRONO_UNITS.find((chronoUnit) => sinceType === chronoUnit.symbol);\n\n    return since * unit.seconds;\n}\n\nfunction splitSinceDuration(since) {\n    const effectiveSince = Math.floor(since);\n\n    for (const chronoUnit of CHRONO_UNITS) {\n        const { seconds, symbol } = chronoUnit;\n\n        if (effectiveSince % seconds === 0) {\n            return {\n                unit: symbol,\n                number: effectiveSince / seconds\n            };\n        }\n    }\n}\n\nfunction getTail() {\n    const inputValue = document.getElementById('tail-input').value;\n    const tail = Number.parseInt(inputValue, 10);\n    return (tail > 0) ? tail : -1;\n}\n\nfunction getDestinationValue() {\n    return document.getElementById('destination-select').value;\n}\n\nfunction isWrapEnabled() {\n    return document.getElementById('wrap-chk').checked;\n}\n\nfunction getDefaultDivHeightValue() {\n    return document.getElementById('follow-lbl').offsetHeight;\n}\n\n(function () {\n    init();\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9sb2dzL2FwcC9tYWluLmpzP2ZiMzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQyxLQUFLLDJCQUEyQjtBQUNoQyxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFvRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLG9EQUFvRDs7QUFFL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsdUJBQXVCO0FBQ3ZDLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGlCQUFpQjtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QseURBQXlEO0FBQ2pIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHVCQUF1QjtBQUN6RixhQUFhO0FBQ2I7QUFDQSxrRUFBa0UsdUJBQXVCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0VBQWtFLHVCQUF1QjtBQUN6RjtBQUNBLGFBQWE7QUFDYjtBQUNBLGtFQUFrRSx1QkFBdUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwREFBMEQsdUJBQXVCO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0EsK0NBQStDLE1BQU07QUFDckQsbUNBQW1DLElBQUksdUJBQXVCLFVBQVUsTUFBTSxNQUFNO0FBQ3BGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU07QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsV0FBVyxFQUFFLFVBQVU7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsa0JBQWtCOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHZzY29kZSA9IGFjcXVpcmVWc0NvZGVBcGkoKTtcblxuY29uc3QgQ0hST05PX1VOSVRTID0gW1xuICAgIHsgc3ltYm9sOiAnaCcsIHNlY29uZHM6IDM2MDAgfSxcbiAgICB7IHN5bWJvbDogJ20nLCBzZWNvbmRzOiA2MCB9LFxuICAgIHsgc3ltYm9sOiAncycsIHNlY29uZHM6IDEgfVxuXTtcblxubGV0IGZ1bGxQYWdlQ29udGVudCA9IHt9O1xubGV0IGZpbHRlcmVkQ29udGVudCA9IHt9O1xubGV0IGZwY0NvdW50ZXIgPSAtMTtcbmxldCBmaWx0ZXJNYXRjaGVkID0gZmFsc2U7XG5sZXQgc2NoZW1hQ29sb3JzO1xubGV0IGRlZmF1bHRDb250YWluZXI7XG5sZXQgaXNUb0JvdHRvbSA9IGZhbHNlO1xubGV0IGlzRm9sbG93UnVuID0gZmFsc2U7XG5sZXQgbGFzdFNjcm9sbFRvcCA9IDA7XG5sZXQgdHlwaW5nVGltZXI7XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRhdGE7XG4gICAgc3dpdGNoIChtZXNzYWdlLmNvbW1hbmQpIHtcbiAgICAgICAgY2FzZSAnaW5pdCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGFpbmVycywgY29sb3JzIH0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgc2NoZW1hQ29sb3JzID0gSlNPTi5wYXJzZShjb2xvcnMpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbnRhaW5lciA9IGNvbnRhaW5lcnNbMF07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJzUGFuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVycy1wYW5lbCcpO1xuICAgICAgICAgICAgY29udGFpbmVyc1BhbmVsLmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc3BsYXktbm9uZScpO1xuICAgICAgICAgICAgY29udGFpbmVyc1BhbmVsLmNsYXNzTGlzdC5hZGQoJ2Rpc3BsYXktaW5saW5lLWJsb2NrJyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IGNyZWF0ZUVsZW1lbnQoJ3ZzY29kZS1zZWxlY3QnKTtcbiAgICAgICAgICAgIHNlbGVjdC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2NvbnRhaW5lcnMtc2VsZWN0Jyk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGFpbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IGNyZWF0ZUVsZW1lbnQoJ3ZzY29kZS1vcHRpb24nLCBjb250YWluZXJzW2ldLCBjb250YWluZXJzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXJzUGFuZWwuYXBwZW5kQ2hpbGQoc2VsZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb250ZW50Jzoge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IG1lc3NhZ2UudGV4dC5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgICAgICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3Q29udGVudCA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdXBkYXRlQ29udGVudChuZXdDb250ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3Jlc2V0Jzoge1xuICAgICAgICAgICAgY29uc3QgeyBmb2xsb3csIHRpbWVzdGFtcCwgc2luY2UsIHRhaWwsIGRlc3RpbmF0aW9uLCB3cmFwIH0gPSBtZXNzYWdlO1xuICAgICAgICAgICAgc2V0U2V0dGluZ3Moe1xuICAgICAgICAgICAgICAgIGZvbGxvdyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgc2luY2UsXG4gICAgICAgICAgICAgICAgdGFpbCxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICB3cmFwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3J1bic6IHtcbiAgICAgICAgICAgIG9uUnVuKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBzZXRTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgIGNvbnN0IHsgZm9sbG93LCB0aW1lc3RhbXAsIHNpbmNlLCB0YWlsLCBkZXN0aW5hdGlvbiwgd3JhcCB9ID0gc2V0dGluZ3M7XG5cbiAgICBpZiAoZm9sbG93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbGxvdy1jaGsnKS5jaGVja2VkID0gZm9sbG93O1xuICAgIH1cblxuICAgIGlmICh0aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGltZXN0YW1wLWNoaycpLmNoZWNrZWQgPSB0aW1lc3RhbXA7XG4gICAgfVxuXG4gICAgaWYgKHNpbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdFNpbmNlRHVyYXRpb24oc2luY2UpO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2luY2UtaW5wdXQnKS52YWx1ZSA9IHNwbGl0Lm51bWJlcjtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpbmNlLXNlbGVjdCcpLnZhbHVlID0gc3BsaXQudW5pdDtcbiAgICB9XG5cbiAgICBpZiAodGFpbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0YWlsLWlucHV0JykudmFsdWUgPSB0YWlsO1xuICAgIH1cblxuICAgIGlmIChkZXN0aW5hdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXN0aW5hdGlvbi1zZWxlY3QnKS52YWx1ZSA9IGRlc3RpbmF0aW9uO1xuICAgIH1cblxuICAgIGlmICh3cmFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dyYXAtY2hrJykuY2hlY2tlZCA9IHdyYXA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgY29uc3QgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCB2YWx1ZSwgY29udGVudCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgIGlmICh2YWx1ZSkgeyBlbGVtZW50LnZhbHVlID0gdmFsdWU7IH1cbiAgICBpZiAoY29udGVudCkgeyBlbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDsgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBvblJ1bigpIHtcbiAgICBjaGFuZ2VWaXNpYmlsaXR5QWZ0ZXJSdW4oKTtcbiAgICBzdGFydExvZygpO1xufVxuXG5mdW5jdGlvbiBpbml0KCkge1xuICAgIGNvbnN0IHJ1bkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdydW5CdG4nKTtcbiAgICBydW5CdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvblJ1bik7XG5cbiAgICBjb25zdCBzdG9wQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0b3BCdG4nKTtcbiAgICBzdG9wQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKF9ldmVudCkgPT4ge1xuICAgICAgICBpc0ZvbGxvd1J1biA9IGZhbHNlO1xuICAgICAgICBjaGFuZ2VWaXNpYmlsaXR5QWZ0ZXJTdG9wKCk7XG4gICAgICAgIHN0b3BMb2coKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGNsZWFyQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NsZWFyQnRuJyk7XG4gICAgY2xlYXJCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoX2V2ZW50KSA9PiB7XG4gICAgICAgIGNoYW5nZVZpc2liaWxpdHlBZnRlckNsZWFyKCk7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNldEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXNldEJ0bicpO1xuICAgIHJlc2V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKF9ldmVudCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc2F2ZVNldHRpbmdzQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NhdmVTZXR0aW5nc0J0bicpO1xuICAgIHNhdmVTZXR0aW5nc0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChfZXZlbnQpID0+IHtcbiAgICAgICAgdnNjb2RlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdzYXZlU2V0dGluZ3MnLFxuICAgICAgICAgICAgZm9sbG93OiBpc0ZvbGxvdygpLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGltZXN0YW1wLWNoaycpLmNoZWNrZWQsXG4gICAgICAgICAgICBzaW5jZTogZ2V0U2luY2VEdXJhdGlvblNlY29uZHMoKSxcbiAgICAgICAgICAgIHRhaWw6IGdldFRhaWwoKSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBnZXREZXN0aW5hdGlvblZhbHVlKCksXG4gICAgICAgICAgICB3cmFwOiBpc1dyYXBFbmFibGVkKClcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBib3R0b21CdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYm90dG9tQnRuJyk7XG4gICAgYm90dG9tQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKF9ldmVudCkgPT4ge1xuICAgICAgICBzY3JvbGxUb0JvdHRvbSgpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgd3JhcENoayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cmFwLWNoaycpO1xuICAgIHdyYXBDaGsuYWRkRXZlbnRMaXN0ZW5lcigndnNjLWNoYW5nZScsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQuZGV0YWlsLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIHN3aXRjaENsYXNzKCdjb250ZW50JywgJ3doaXRlLXNwYWNlLXByZScsICd3aGl0ZS1zcGFjZS13cmFwJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2hDbGFzcygnY29udGVudCcsICd3aGl0ZS1zcGFjZS13cmFwJywgJ3doaXRlLXNwYWNlLXByZScpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBmaWx0ZXJTZWxlY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLXNlbGVjdCcpO1xuICAgIGZpbHRlclNlbGVjdC5hZGRFdmVudExpc3RlbmVyKCd2c2MtY2hhbmdlJywgKF9ldmVudCkgPT4ge1xuICAgICAgICByZXNldEZpbHRlcigpO1xuICAgICAgICBpZiAoaXNSdW4oKSAmJiBpc0ZpbHRlcmluZygpKSB7XG4gICAgICAgICAgICBydW5GaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZmlsdGVySW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLWlucHV0Jyk7XG4gICAgZmlsdGVySW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoX2V2ZW50KSA9PiB7XG4gICAgICAgIHJlc2V0RmlsdGVyKCk7XG4gICAgICAgIGlmICghaXNSdW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBpbmdUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHR5cGluZ1RpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBpbmdUaW1lciA9IHNldFRpbWVvdXQocnVuRmlsdGVyLCA1MDApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgbG9nUGFuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nUGFuZWwnKTtcbiAgICBjb25zdCB0b0JvdHRvbSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgc3QgPSBsb2dQYW5lbC5zY3JvbGxUb3A7XG4gICAgICAgIGlmIChzdCA+IGxhc3RTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIC8vIHNjcm9sbCBkb3duXG4gICAgICAgICAgICBpc1RvQm90dG9tID0gKGxvZ1BhbmVsLnNjcm9sbFRvcCArIHdpbmRvdy5pbm5lckhlaWdodCkgPj0gbG9nUGFuZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2Nyb2xsIHVwXG4gICAgICAgICAgICBpc1RvQm90dG9tID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFNjcm9sbFRvcCA9IHN0IDw9IDAgPyAwIDogc3Q7XG4gICAgICAgIHJlbmRlckJ5UGFnaW5hdGlvbigpO1xuICAgIH0sIDI1MCk7XG4gICAgbG9nUGFuZWwuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0b0JvdHRvbSk7XG5cbiAgICB2c2NvZGUucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBjb21tYW5kOiAncG9zdEluaXRpYWxpemUnXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q29udGVudCgpIHtcbiAgICBmdWxsUGFnZUNvbnRlbnQgPSB7fTtcbiAgICBmcGNDb3VudGVyID0gLTE7XG59XG5cbmZ1bmN0aW9uIHJlc2V0RmlsdGVyKCkge1xuICAgIGZpbHRlcmVkQ29udGVudCA9IHt9O1xuICAgIGZpbHRlck1hdGNoZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcnVuRmlsdGVyKCkge1xuICAgIGVtcHR5Q29udGVudCgpO1xuICAgIHNhdmVGaWx0ZXJlZENvbnRlbnQoKTtcbiAgICBzZXRIZWlnaHRDb250ZW50UGFuZWwoKTtcbiAgICByZW5kZXJCeVBhZ2luYXRpb24oKTtcbn1cblxuZnVuY3Rpb24gY2hhbmdlVmlzaWJpbGl0eUFmdGVyUnVuKCkge1xuICAgIGlmIChnZXREZXN0aW5hdGlvblZhbHVlKCkgPT09ICdUZXJtaW5hbCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnVuQnRuJykuY2xhc3NMaXN0LmFkZCgnZGlzcGxheS1ub25lJyk7XG4gICAgaWYgKGlzRm9sbG93KCkpIHtcbiAgICAgICAgc3dpdGNoQ2xhc3MoJ3N0b3BCdG4nLCAnZGlzcGxheS1ub25lJywgJ2Rpc3BsYXktaW5saW5lLWJsb2NrJyk7XG4gICAgfVxuICAgIHN3aXRjaENsYXNzKCdjbGVhckJ0bicsICdkaXNwbGF5LW5vbmUnLCAnZGlzcGxheS1pbmxpbmUtYmxvY2snKTtcbn1cblxuZnVuY3Rpb24gY2hhbmdlVmlzaWJpbGl0eUFmdGVyQ2xlYXIoKSB7XG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdG9wQnRuJykuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNwbGF5LW5vbmUnKSkge1xuICAgICAgICBzd2l0Y2hDbGFzcygnY2xlYXJCdG4nLCAnZGlzcGxheS1pbmxpbmUtYmxvY2snLCAnZGlzcGxheS1ub25lJyk7XG4gICAgICAgIHN3aXRjaENsYXNzKCdydW5CdG4nLCAnZGlzcGxheS1ub25lJywgJ2Rpc3BsYXktaW5saW5lLWJsb2NrJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGFuZ2VWaXNpYmlsaXR5QWZ0ZXJTdG9wKCkge1xuICAgIHN3aXRjaENsYXNzKCdzdG9wQnRuJywgJ2Rpc3BsYXktaW5saW5lLWJsb2NrJywgJ2Rpc3BsYXktbm9uZScpO1xufVxuXG5mdW5jdGlvbiBzd2l0Y2hDbGFzcyhpZCwgY2xhc3NUb1JlbW92ZSwgY2xhc3NUb0FkZCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzVG9SZW1vdmUpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc1RvUmVtb3ZlKTtcbiAgICB9XG4gICAgaWYgKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc1RvQWRkKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NUb0FkZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1J1bigpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3J1bkJ0bicpLmNsYXNzTGlzdC5jb250YWlucygnZGlzcGxheS1ub25lJyk7XG59XG5cbmZ1bmN0aW9uIGlzRmlsdGVyaW5nKCkge1xuICAgIGNvbnN0IGZpbHRlcklucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1pbnB1dCcpLnZhbHVlO1xuICAgIHJldHVybiBmaWx0ZXJJbnB1dC5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBzdGFydExvZygpIHtcbiAgICByZXNldENvbnRlbnQoKTtcbiAgICByZXNldEZpbHRlcigpO1xuICAgIGNsZWFyKCk7XG4gICAgaXNGb2xsb3dSdW4gPSBpc0ZvbGxvdygpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGNvbnRhaW5lcjogZ2V0Q29udGFpbmVyKCksXG4gICAgICAgIGZvbGxvdzogaXNGb2xsb3dSdW4sXG4gICAgICAgIHRpbWVzdGFtcDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVzdGFtcC1jaGsnKS5jaGVja2VkLFxuICAgICAgICBzaW5jZTogZ2V0U2luY2VEdXJhdGlvblN0cmluZygpLFxuICAgICAgICB0YWlsOiBnZXRUYWlsKCksXG4gICAgICAgIGRlc3RpbmF0aW9uOiBnZXREZXN0aW5hdGlvblZhbHVlKClcbiAgICB9O1xuICAgIHZzY29kZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGNvbW1hbmQ6ICdzdGFydCcsXG4gICAgICAgIG9wdGlvbnM6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHN0b3BMb2coKSB7XG4gICAgdnNjb2RlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY29tbWFuZDogJ3N0b3AnXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGlmICghaXNGb2xsb3dSdW4pIHtcbiAgICAgICAgcmVzZXRDb250ZW50KCk7XG4gICAgICAgIHJlc2V0RmlsdGVyKCk7XG4gICAgfVxuICAgIHNldEhlaWdodENvbnRlbnRQYW5lbCh0cnVlKTtcbiAgICBlbXB0eUNvbnRlbnQoKTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY29uc3QgY29udGFpbmVyc1NlbGVjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXJzLXNlbGVjdCcpO1xuICAgIGlmIChjb250YWluZXJzU2VsZWN0KSB7XG4gICAgICAgIGNvbnRhaW5lcnNTZWxlY3Quc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgdnNjb2RlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgY29tbWFuZDogJ3Jlc2V0J1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZW50KG5ld0NvbnRlbnQpIHtcbiAgICBsZXQgY29udGVudCA9IHt9O1xuICAgIGxldCBjb3VudGVyID0gMDtcblxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBuZXdDb250ZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnRbY291bnRlcl0gPSBlbGVtZW50O1xuICAgICAgICAgICAgZnBjQ291bnRlcisrO1xuICAgICAgICAgICAgZnVsbFBhZ2VDb250ZW50W2ZwY0NvdW50ZXJdID0gZWxlbWVudDtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRlbnQgPSBzYXZlRmlsdGVyZWRDb250ZW50KGNvbnRlbnQpO1xuICAgIHNldEhlaWdodENvbnRlbnRQYW5lbCgpO1xuICAgIHJlbmRlckJ5UGFnaW5hdGlvbihjb250ZW50KTtcbiAgICBzd2l0Y2hDbGFzcygnY2xlYXJCdG4nLCAnZGlzcGxheS1ub25lJywgJ2Rpc3BsYXktaW5saW5lLWJsb2NrJyk7XG59XG5cbmZ1bmN0aW9uIHNldEhlaWdodENvbnRlbnRQYW5lbChyZW1vdmVTdHlsZSkge1xuICAgIGlmIChyZW1vdmVTdHlsZSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5uZXJMb2dQYW5lbCcpLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdoZWlnaHQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gaXNGaWx0ZXJpbmcoKSA/IGZpbHRlcmVkQ29udGVudCA6IGZ1bGxQYWdlQ29udGVudDtcbiAgICAgICAgY29uc3Qgcm93cyA9IE9iamVjdC5rZXlzKGNvbnRlbnQpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0RGl2ID0gZ2V0RGVmYXVsdERpdkhlaWdodFZhbHVlKCk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbm5lckxvZ1BhbmVsJykuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0RGl2ICogcm93c31weGA7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzYXZlRmlsdGVyZWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBsZXQgY29udGVudEFmdGVyRmlsdGVyO1xuICAgIGlmIChpc0ZpbHRlcmluZygpKSB7XG4gICAgICAgIGNvbnRlbnRBZnRlckZpbHRlciA9IGZpbHRlcihjb250ZW50KTtcbiAgICAgICAgbGV0IGZjUm93cyA9IE9iamVjdC5rZXlzKGZpbHRlcmVkQ29udGVudCkubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGZjUm93cyA9PT0gLTEpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQ29udGVudCA9IGNvbnRlbnRBZnRlckZpbHRlcjtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50QWZ0ZXJGaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBPYmplY3Qua2V5cyhjb250ZW50QWZ0ZXJGaWx0ZXIpLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBmY1Jvd3MrKztcbiAgICAgICAgICAgIGZpbHRlcmVkQ29udGVudFtmY1Jvd3NdID0gY29udGVudEFmdGVyRmlsdGVyW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50QWZ0ZXJGaWx0ZXI7XG59XG5cbmZ1bmN0aW9uIGZpbHRlcihsb2dzKSB7XG4gICAgY29uc3QgdGV4dCA9IGxvZ3MgPyBsb2dzIDogZnVsbFBhZ2VDb250ZW50O1xuICAgIGNvbnN0IGZpbHRlcklucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbHRlci1pbnB1dCcpLnZhbHVlO1xuICAgIGNvbnN0IG1vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsdGVyLXNlbGVjdCcpLnZhbHVlO1xuICAgIGxldCBjb250ZW50ID0ge307XG4gICAgaWYgKGZpbHRlcklucHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGZpbHRlcklucHV0KTtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdpbmNsdWRlJzpcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gZmlsdGVyQnlGdW5jdGlvbih0ZXh0LCAodmFsdWUpID0+IHJlZ2V4LnRlc3QodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2V4Y2x1ZGUnOlxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBmaWx0ZXJCeUZ1bmN0aW9uKHRleHQsICh2YWx1ZSkgPT4gIXJlZ2V4LnRlc3QodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXJNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlckJlZm9yZVJlc3VsdCA9IGZpbHRlckJlZm9yZSh0ZXh0LCByZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBmaWx0ZXJCZWZvcmVSZXN1bHQuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyTWF0Y2hlZCA9IGZpbHRlckJlZm9yZVJlc3VsdC5tYXRjaGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlck1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyQWZ0ZXJSZXN1bHQgPSBmaWx0ZXJBZnRlcih0ZXh0LCByZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBmaWx0ZXJBZnRlclJlc3VsdC5jb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJNYXRjaGVkID0gZmlsdGVyQWZ0ZXJSZXN1bHQubWF0Y2hlZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudCA9IHRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckJ5RnVuY3Rpb24odGV4dCwgZnVuYykge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB7fTtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgbGV0IGlubmVyQ291bnRlciA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0ZXh0W2NvdW50ZXJdO1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVuYyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRbaW5uZXJDb3VudGVyXSA9IHZhbHVlO1xuICAgICAgICAgICAgaW5uZXJDb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlcisrO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gZmlsdGVyQmVmb3JlKHRleHQsIHJlZ2V4KSB7XG4gICAgY29uc3QgY29udGVudCA9IHt9O1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dFtjb3VudGVyXTtcbiAgICAgICAgbWF0Y2hlZCA9IHJlZ2V4LnRlc3QodmFsdWUpO1xuICAgICAgICBpZiAoIXZhbHVlIHx8IG1hdGNoZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRbY291bnRlcl0gPSB2YWx1ZTtcbiAgICAgICAgY291bnRlcisrO1xuICAgIH1cbiAgICByZXR1cm4geyBtYXRjaGVkLCBjb250ZW50IH07XG59XG5cbmZ1bmN0aW9uIGZpbHRlckFmdGVyKHRleHQsIHJlZ2V4KSB7XG4gICAgY29uc3QgY29udGVudCA9IHt9O1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBsZXQgaW5uZXJDb3VudGVyID0gMDtcbiAgICBsZXQgc3RhcnQgPSBmYWxzZTtcbiAgICBsZXQgbWF0Y2hlZCA9IGZhbHNlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGV4dFtjb3VudGVyXTtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2hlZCA9IHJlZ2V4LnRlc3QodmFsdWUpO1xuICAgICAgICBpZiAoIXN0YXJ0ICYmIG1hdGNoZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnRlbnRbaW5uZXJDb3VudGVyXSA9IHZhbHVlO1xuICAgICAgICAgICAgaW5uZXJDb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgICAgY291bnRlcisrO1xuICAgIH1cbiAgICByZXR1cm4geyBtYXRjaGVkLCBjb250ZW50IH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5Q29udGVudCgpIHtcbiAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lubmVyTG9nUGFuZWwnKTtcbiAgICBsZXQgaSA9IGNvbnRlbnREaXYuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb250ZW50RGl2LnJlbW92ZUNoaWxkKGNvbnRlbnREaXYuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gYDxjb2RlIGlkPSdjb250ZW50JyBjbGFzcz0nJHtpc1dyYXBFbmFibGVkKCkgPyAnd2hpdGUtc3BhY2Utd3JhcCcgOiAnd2hpdGUtc3BhY2UtcHJlJ30gcG9zaXRpb24tcmVsYXRpdmUnPjwvY29kZT5gO1xufVxuXG5mdW5jdGlvbiByZW5kZXJCeVBhZ2luYXRpb24oY29udGVudFRvQWRkKSB7XG4gICAgaWYgKGNvbnRlbnRUb0FkZCAmJiBPYmplY3Qua2V5cyhjb250ZW50VG9BZGQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZ1bGxGaWx0ZXJlZENvbnRlbnQgPSBpc0ZpbHRlcmluZygpID8gZmlsdGVyZWRDb250ZW50IDogZnVsbFBhZ2VDb250ZW50O1xuICAgIGNvbnN0IHRvdGFsUm93cyA9IE9iamVjdC5rZXlzKGZ1bGxGaWx0ZXJlZENvbnRlbnQpLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgaGVpZ2h0RGl2ID0gZ2V0RGVmYXVsdERpdkhlaWdodFZhbHVlKCk7XG4gICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZ1BhbmVsJykuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IHJlZmVyZW5jZVJvdyA9IE1hdGguZmxvb3IoY3VycmVudFBvc2l0aW9uIC8gaGVpZ2h0RGl2KTtcbiAgICAvLyBpZGVudGlmeSByb3dzIHJhbmdlIHRvIGRyYXdcbiAgICBsZXQgbG93ZXJSYW5nZSA9IHJlZmVyZW5jZVJvdyAtIDI1MCA8IDAgPyAwIDogcmVmZXJlbmNlUm93IC0gMjUwO1xuICAgIGxldCB1cHBlclJhbmdlID0gcmVmZXJlbmNlUm93ICsgMjUwID4gdG90YWxSb3dzID8gdG90YWxSb3dzIDogcmVmZXJlbmNlUm93ICsgMjUwO1xuICAgIGxldCBpc1ByZXBlbmQgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNoaWxkcmVuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnQnKS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIGlkZW50aWZ5IHJvd3MgcmFuZ2UgcHJlc2VudCBpbiBET01cbiAgICAgICAgY29uc3QgbG93ZXN0Um93SW5ET00gPSBwYXJzZUludChjaGlsZHJlbi5pdGVtKDApLmlkKTtcbiAgICAgICAgY29uc3QgdXBwZXN0Um93SW5ET00gPSBwYXJzZUludChjaGlsZHJlbi5pdGVtKGNoaWxkcmVuLmxlbmd0aCAtIDEpLmlkKTtcbiAgICAgICAgaWYgKGxvd2VyUmFuZ2UgPCBsb3dlc3RSb3dJbkRPTSkge1xuICAgICAgICAgICAgaWYgKHVwcGVyUmFuZ2UgPj0gbG93ZXN0Um93SW5ET00pIHtcbiAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbih1cHBlclJhbmdlICsgMSwgdXBwZXN0Um93SW5ET00pO1xuICAgICAgICAgICAgICAgIHVwcGVyUmFuZ2UgPSBsb3dlc3RSb3dJbkRPTSAtIDE7XG4gICAgICAgICAgICAgICAgaXNQcmVwZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGVudCcpLnN0eWxlLnRvcCA9IGAke2xvd2VyUmFuZ2UgKiBoZWlnaHREaXZ9cHhgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbXB0eUNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGVudCcpLnN0eWxlLnRvcCA9IGAke2xvd2VyUmFuZ2UgKiBoZWlnaHREaXZ9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGV4dHJhY3RSb3dzVG9EcmF3KGZ1bGxGaWx0ZXJlZENvbnRlbnQsIGxvd2VyUmFuZ2UsIHVwcGVyUmFuZ2UpO1xuICAgICAgICAgICAgcmVuZGVyKGJlYXV0aWZ5TGluZXMoY29udGVudCksIGxvd2VyUmFuZ2UsIGlzUHJlcGVuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXBwZXJSYW5nZSA+IHVwcGVzdFJvd0luRE9NKSB7XG4gICAgICAgICAgICBpZiAobG93ZXJSYW5nZSA8PSB1cHBlc3RSb3dJbkRPTSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGxvd2VzdFJvd0luRE9NLCBsb3dlclJhbmdlIC0gMSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnQnKS5zdHlsZS50b3AgPSBgJHtsb3dlclJhbmdlICogaGVpZ2h0RGl2fXB4YDtcbiAgICAgICAgICAgICAgICBsb3dlclJhbmdlID0gdXBwZXN0Um93SW5ET00gKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbXB0eUNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGVudCcpLnN0eWxlLnRvcCA9IGAke2xvd2VyUmFuZ2UgKiBoZWlnaHREaXZ9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGV4dHJhY3RSb3dzVG9EcmF3KGZ1bGxGaWx0ZXJlZENvbnRlbnQsIGxvd2VyUmFuZ2UsIHVwcGVyUmFuZ2UpO1xuICAgICAgICAgICAgcmVuZGVyKGJlYXV0aWZ5TGluZXMoY29udGVudCksIGxvd2VyUmFuZ2UsIGlzUHJlcGVuZCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZXh0cmFjdFJvd3NUb0RyYXcoZnVsbEZpbHRlcmVkQ29udGVudCwgbG93ZXJSYW5nZSwgdXBwZXJSYW5nZSk7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250ZW50Jykuc3R5bGUudG9wID0gYCR7bG93ZXJSYW5nZSAqIGhlaWdodERpdn1weGA7XG4gICAgICAgIHJlbmRlcihiZWF1dGlmeUxpbmVzKGNvbnRlbnQpLCBsb3dlclJhbmdlLCBpc1ByZXBlbmQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdFJvd3NUb0RyYXcoY29udGVudCwgZnJvbSwgdG8pIHtcbiAgICBjb25zdCBjb250ZW50RXh0cmFjdGVkID0ge307XG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPD0gdG87IGkgKz0gMSkge1xuICAgICAgICBjb250ZW50RXh0cmFjdGVkW2ldID0gY29udGVudFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnRFeHRyYWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIGJlYXV0aWZ5TGluZXMoY29udGVudExpbmVzKSB7XG4gICAgY29uc3QgY29udGVudCA9IHt9O1xuICAgIGlmIChPYmplY3Qua2V5cyhjb250ZW50TGluZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBoZWlnaHREaXYgPSBnZXREZWZhdWx0RGl2SGVpZ2h0VmFsdWUoKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRlbnRMaW5lcykpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICAgICAgdmFsdWUgPSBoaWdobGlnaHRXb3Jkcyh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gL1xcbiQvLnRlc3QodmFsdWUpID8gdmFsdWUgOiBgJHt2YWx1ZX1cXG5gO1xuICAgICAgICBjb250ZW50W2tleV0gPSBgPGRpdiBpZD1cIiR7a2V5fVwiIHN0eWxlPVwibWluLWhlaWdodDogJHtoZWlnaHREaXZ9cHhcIj4ke3ZhbHVlfTwvZGl2PmA7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xufVxuXG5mdW5jdGlvbiBoaWdobGlnaHRXb3Jkcyhyb3cpIHtcbiAgICBpZiAoIXNjaGVtYUNvbG9ycykge1xuICAgICAgICByZXR1cm4gcm93O1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcnVsZSBvZiBzY2hlbWFDb2xvcnMpIHtcbiAgICAgICAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChydWxlLnJlZ2V4LCBcImdpXCIpO1xuICAgICAgICBpZiAocmVnZXhwLnRlc3Qocm93KSkge1xuICAgICAgICAgICAgcm93ID0gcm93LnJlcGxhY2VBbGwocmVnZXhwLCByZXBsKTtcbiAgICAgICAgICAgIHJvdyA9IHJvdy5yZXBsYWNlQWxsKCcjcnVsZUNvbG9yJywgcnVsZS5jb2xvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvdztcbn1cblxuZnVuY3Rpb24gcmVwbCgpIHtcbiAgICBjb25zdCBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBtYXRjaCA9IGFyZ3VtZW50c1swXTtcbiAgICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IGFyZ3VtZW50c1thcmdzTGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIW9yaWdpbmFsU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICBjb25zdCBvZmZzZXQgPSBhcmd1bWVudHNbYXJnc0xlbmd0aCAtIDJdO1xuXG4gICAgY29uc3Qgc3Vic3RyaW5nID0gb3JpZ2luYWxTdHJpbmcuc3Vic3RyaW5nKDAsIG9mZnNldCArIG1hdGNoLmxlbmd0aCk7XG4gICAgY29uc3QgaW5kZXhPcGVuU3BhbiA9IHN1YnN0cmluZy5sYXN0SW5kZXhPZihcIjxzcGFuXCIpO1xuICAgIGNvbnN0IGluZGV4Q2xvc2VTcGFuID0gc3Vic3RyaW5nLmxhc3RJbmRleE9mKFwiPC9zcGFuPlwiKTtcbiAgICBpZiAoaW5kZXhPcGVuU3BhbiA9PT0gLTEgfHwgaW5kZXhPcGVuU3BhbiA8IGluZGV4Q2xvc2VTcGFuKSB7XG4gICAgICAgIHJldHVybiBgPHNwYW4gY2xhc3M9XCIjcnVsZUNvbG9yXCI+JHttYXRjaH08L3NwYW4+YDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGZyb20sIHRvKSB7XG4gICAgaWYgKHRvIDwgZnJvbSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDw9IHRvOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9EZWxldGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAodG9EZWxldGUpIHtcbiAgICAgICAgICAgIHRvRGVsZXRlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXIoY29udGVudCwgZnJvbSwgcHJlcGVuZCkge1xuICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnQnKTtcblxuICAgIGlmIChPYmplY3Qua2V5cyhjb250ZW50KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCgnTm8gbG9ncyAuLi4nKTtcbiAgICAgICAgY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUb0Rpc3BsYXkgPSBjb25jYXRlbmF0ZU9iamVjdFZhbHVlc0FzU3RyaW5nKGNvbnRlbnQsIGZyb20pO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGNvbnRlbnRUb0Rpc3BsYXkpO1xuICAgICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICAgICAgY29udGVudEVsZW1lbnQucHJlcGVuZChmcmFnbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50RWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVG9Cb3R0b20pIHtcbiAgICAgICAgICAgIHNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbmNhdGVuYXRlT2JqZWN0VmFsdWVzQXNTdHJpbmcob2JqZWN0LCBpeCkge1xuICAgIGxldCB2YWx1ZXNDb25jYXRlbmF0ZWQgPSAnJztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtpeF07XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc0NvbmNhdGVuYXRlZCArPSB2YWx1ZTtcbiAgICAgICAgaXgrKztcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlc0NvbmNhdGVuYXRlZDtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG9Cb3R0b20oKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JvdHRvbScpLnNjcm9sbEludG9WaWV3KCk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRhaW5lcigpIHtcbiAgICBjb25zdCBjb250YWluZXJzU2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcnMtc2VsZWN0Jyk7XG4gICAgcmV0dXJuIChjb250YWluZXJzU2VsZWN0KSA/IGNvbnRhaW5lcnNTZWxlY3QudmFsdWUgOiBkZWZhdWx0Q29udGFpbmVyO1xufVxuXG5mdW5jdGlvbiBpc0ZvbGxvdygpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbGxvdy1jaGsnKS5jaGVja2VkO1xufVxuXG5mdW5jdGlvbiBnZXRTaW5jZUR1cmF0aW9uU3RyaW5nKCkge1xuICAgIGNvbnN0IHNpbmNlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2luY2UtaW5wdXQnKS52YWx1ZTtcblxuICAgIGlmIChzaW5jZUlucHV0IDw9IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3Qgc2luY2VUeXBlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpbmNlLXNlbGVjdCcpLnZhbHVlO1xuICAgIHJldHVybiBgJHtzaW5jZUlucHV0fSR7c2luY2VUeXBlfWA7XG59XG5cbmZ1bmN0aW9uIGdldFNpbmNlRHVyYXRpb25TZWNvbmRzKCkge1xuICAgIGNvbnN0IHNpbmNlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2luY2UtaW5wdXQnKS52YWx1ZTtcbiAgICBjb25zdCBzaW5jZSA9IE51bWJlci5wYXJzZUludChzaW5jZUlucHV0LCAxMCk7XG5cbiAgICBpZiAoc2luY2UgPD0gMCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgY29uc3Qgc2luY2VUeXBlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NpbmNlLXNlbGVjdCcpLnZhbHVlO1xuICAgIGNvbnN0IHVuaXQgPSBDSFJPTk9fVU5JVFMuZmluZCgoY2hyb25vVW5pdCkgPT4gc2luY2VUeXBlID09PSBjaHJvbm9Vbml0LnN5bWJvbCk7XG5cbiAgICByZXR1cm4gc2luY2UgKiB1bml0LnNlY29uZHM7XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2luY2VEdXJhdGlvbihzaW5jZSkge1xuICAgIGNvbnN0IGVmZmVjdGl2ZVNpbmNlID0gTWF0aC5mbG9vcihzaW5jZSk7XG5cbiAgICBmb3IgKGNvbnN0IGNocm9ub1VuaXQgb2YgQ0hST05PX1VOSVRTKSB7XG4gICAgICAgIGNvbnN0IHsgc2Vjb25kcywgc3ltYm9sIH0gPSBjaHJvbm9Vbml0O1xuXG4gICAgICAgIGlmIChlZmZlY3RpdmVTaW5jZSAlIHNlY29uZHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdW5pdDogc3ltYm9sLFxuICAgICAgICAgICAgICAgIG51bWJlcjogZWZmZWN0aXZlU2luY2UgLyBzZWNvbmRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYWlsKCkge1xuICAgIGNvbnN0IGlucHV0VmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGFpbC1pbnB1dCcpLnZhbHVlO1xuICAgIGNvbnN0IHRhaWwgPSBOdW1iZXIucGFyc2VJbnQoaW5wdXRWYWx1ZSwgMTApO1xuICAgIHJldHVybiAodGFpbCA+IDApID8gdGFpbCA6IC0xO1xufVxuXG5mdW5jdGlvbiBnZXREZXN0aW5hdGlvblZhbHVlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVzdGluYXRpb24tc2VsZWN0JykudmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzV3JhcEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3cmFwLWNoaycpLmNoZWNrZWQ7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXZIZWlnaHRWYWx1ZSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvbGxvdy1sYmwnKS5vZmZzZXRIZWlnaHQ7XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgaW5pdCgpO1xufSkoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);